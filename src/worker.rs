use std::time::Duration;

use tokio::{
    sync::{mpsc, oneshot},
    time::sleep,
};

use crate::model::WorkerRequest;

/// Maximum number of retries for failed requests
const MAX_RETRIES: usize = 10;

/// Provides a background worker task that sends the messages generated by the
/// layer.
pub(crate) async fn worker(
    webhook_url: &str,
    mut rx: mpsc::UnboundedReceiver<WorkerRequest>,
    shutdown_tx: oneshot::Sender<()>,
) {
    let client = reqwest::Client::new();
    while let Some(message) = rx.recv().await {
        match message {
            WorkerRequest::Post(message) => {
                let payload_str = serde_json::to_string(&message).unwrap();

                let mut retries = 0;
                while retries < MAX_RETRIES {
                    retries += 1;

                    let req = client
                        .post(webhook_url)
                        .header("Content-Type", "application/json")
                        .body(payload_str.clone())
                        .send()
                        .await;

                    let req = match req {
                        Ok(v) => v.status(),
                        Err(_) => continue,
                    };

                    if req.is_server_error() {
                        sleep(Duration::from_millis(100)).await;
                        continue;
                    }

                    break;
                }
            }
            WorkerRequest::Shutdown => break,
        }
    }

    let _ = shutdown_tx.send(());
}
